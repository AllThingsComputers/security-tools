package main

import (
	"encoding/json"
	"fmt"
	"log"

	"golang.org/x/sys/windows/registry"
)

type Exploit struct {
	Name  string `json:"name"`
	CVEID int    `json:"cveid"`
	URL   string `json:"url"`
}

type Vulnerabilities struct {
	AffectedProduct string    `json:"affectedProduct"`
	AffectedBuild   string    `json:"CurrentBuild"`
	Source          string    `json:"source"`
	Active          bool      `json:"active"`
	Exploits        []Exploit `json:"exploits"`
}

func getWindowsInfo() (string, string, string, string, error) {
	k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Windows NT\CurrentVersion`, registry.QUERY_VALUE)
	if err != nil {
		return "", "", "", "", err
	}
	defer k.Close()

	productName, err := k.GetStringValue("ProductName")
	if err != nil {
		return "", "", "", "", err
	}

	currentBuild, err := k.GetStringValue("CurrentBuild")
	if err != nil {
		return "", "", "", "", err
	}

	displayVersion, err := k.GetStringValue("DisplayVersion")
	if err != nil {
		return "", "", "", "", err
	}

	editionID, err := k.GetStringValue("EditionID")
	if err != nil {
		return "", "", "", "", err
	}

	return productName, currentBuild, displayVersion, editionID, nil
}

func main() {
	productName, currentBuild, displayVersion, editionID, err := getWindowsInfo()
	if err != nil {
		log.Fatalf("Error fetching Windows info: %v", err)
	}

	fmt.Printf("Product Name: %s\nCurrent Build: %s\nDisplay Version: %s\nEdition ID: %s\n",
		productName, currentBuild, displayVersion, editionID)

	// Define a sample JSON string for vulnerabilities
	jsonString := `{
		"affectedProduct": "Windows 10 Enterprise",
		"CurrentBuild": "19045",
		"source": "www.cvedetails.com",
		"active": true,
		"exploits": [
			{
				"name": "Windows Secure Socket Tunneling Protocol (SSTP) Remote Code Execution Vulnerability",
				"cveid": 202244680,
				"url": "www.example.com"
			},
			{
				"name": "Windows Graphics Component Elevation of Privilege Vulnerability",
				"cveid": 202244681,
				"url": "www.example.org"
			}
		]
	}`

	var vulnerabilities Vulnerabilities
	err = json.Unmarshal([]byte(jsonString), &vulnerabilities)
	if err != nil {
		log.Fatalf("Error decoding JSON: %v", err)
	}

	fmt.Println("\nVulnerability Details:")
	fmt.Printf("Affected Product: %s\nAffected Build: %s\nSource: %s\nActive: %t\n",
		vulnerabilities.AffectedProduct, vulnerabilities.AffectedBuild, vulnerabilities.Source, vulnerabilities.Active)

	// Check for a match
	if vulnerabilities.AffectedProduct == productName && vulnerabilities.AffectedBuild == currentBuild {
		fmt.Println("\nWe have a match! Vulnerabilities detected:")
		for _, exploit := range vulnerabilities.Exploits {
			fmt.Printf(" - %s (CVE ID: %d)\n   URL: %s\n", exploit.Name, exploit.CVEID, exploit.URL)
		}
	} else {
		fmt.Println("\nNo match found. The system appears secure.")
	}
}
